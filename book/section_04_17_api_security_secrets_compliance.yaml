# section_04_17_api_security_secrets_compliance.yaml

---
document_info:
  title: "API Security, Secrets Management, and Compliance"
  book: "AI Security Mastery: From ML Fundamentals to Production Detection Systems"
  chapter: 4
  section: 17
  part: 3
  author: "Raghav Dinesh"
  github: "https://github.com/raghavpoonia/ai-security-mastery"
  license: "MIT"
  created: "2026-01-28"
  version: "1.0"
  description: |
    Complete guide to API security, secrets management, and regulatory compliance for
    production LLM systems. Covers authentication (API keys, OAuth, JWT), authorization
    (RBAC, ABAC), rate limiting, secrets management (HashiCorp Vault, AWS Secrets Manager),
    audit logging, and compliance frameworks (GDPR, SOC2, HIPAA, ISO 27001). Implements
    production-grade security controls with comprehensive audit trails, secret rotation,
    and compliance automation. Security analysis covering API key compromise, privilege
    escalation, secrets exposure, and compliance violations. Essential for building secure,
    compliant LLM services.
  estimated_pages: 8
  tags:
    - api-security
    - authentication
    - authorization
    - secrets-management
    - compliance
    - gdpr
    - soc2
    - audit-logging
    - rbac

section_overview:
  title: "API Security, Secrets Management, and Compliance"
  number: "4.17"
  
  purpose: |
    Section 4.16 built comprehensive monitoring with logging, metrics, and tracing. We have
    visibility into system behavior. But visibility alone doesn't prevent attacks—we need
    robust security controls: authentication to verify identity, authorization to enforce
    access, and secrets management to protect credentials.
    
    Production LLM APIs handle sensitive data and expensive resources. Without proper security,
    attackers steal API keys ($10K+ in GPU abuse), access unauthorized data (privacy
    violations), and bypass rate limits (DoS). Compliance requirements (GDPR, SOC2, HIPAA)
    mandate specific controls: audit logging, data protection, access controls.
    
    This section builds complete security and compliance systems: multi-factor authentication,
    role-based access control, secrets rotation, audit trails, and regulatory compliance
    automation. Understanding these patterns is critical—security and compliance are not
    optional for production systems.
  
  learning_objectives:
    conceptual:
      - "Understand authentication mechanisms: API keys, OAuth, JWT, and their trade-offs"
      - "Grasp authorization models: RBAC, ABAC, and permission enforcement"
      - "Comprehend secrets management: rotation, encryption, and secure storage"
      - "Understand compliance frameworks: GDPR, SOC2, HIPAA requirements"
    
    practical:
      - "Implement API key authentication with secure generation and storage"
      - "Build RBAC system with roles, permissions, and policy enforcement"
      - "Deploy secrets management with HashiCorp Vault or cloud providers"
      - "Create audit logging system for compliance and forensics"
    
    security_focused:
      - "Prevent API key compromise through rotation and scoping"
      - "Detect and prevent privilege escalation attacks"
      - "Implement defense-in-depth for secrets protection"
      - "Ensure compliance with data protection regulations"
  
  prerequisites:
    knowledge:
      - "Section 4.16: Monitoring and observability"
      - "Section 4.14: Horizontal scaling and distributed deployment"
      - "Understanding of authentication and authorization concepts"
      - "Familiarity with compliance requirements (GDPR basics)"
    
    skills:
      - "Implementing authentication systems"
      - "Working with secrets management tools"
      - "Understanding of cryptographic concepts"
      - "Compliance documentation and audit preparation"
  
  key_transitions:
    from_section_4_16: |
      Section 4.16 built comprehensive monitoring with structured logging, metrics, and
      tracing. This provides visibility into system behavior and audit trails for forensics.
      
      Section 4.17 adds security controls that monitoring tracks: authentication (who),
      authorization (what), secrets management (credentials), and compliance (regulations).
      Monitoring from 4.16 provides the audit logs that compliance in 4.17 requires.
    
    to_next_section: |
      Section 4.17 covers defensive security (authentication, authorization, compliance).
      Section 4.18 advances to offensive security: advanced attacks on production systems,
      red team testing, and adversarial techniques. Together they provide complete security
      perspective.

topics:
  - topic_number: 1
    title: "Authentication, Authorization, and Access Control"
    
    overview: |
      Authentication verifies identity ("who are you?"), authorization determines permissions
      ("what can you do?"). For LLM APIs, authentication options include API keys (simple),
      OAuth (delegated access), and JWT (stateless tokens). Authorization models include
      RBAC (role-based) and ABAC (attribute-based).
      
      Production systems need robust authentication with secure key generation, rotation,
      and revocation. Authorization requires fine-grained permissions: which models users
      access, usage quotas, feature flags. Rate limiting prevents abuse, and audit logging
      tracks all access for compliance.
      
      We implement complete authentication and authorization systems, build secure API key
      management, deploy RBAC with policy enforcement, and configure comprehensive rate
      limiting. Understanding these patterns enables building secure, compliant APIs.
    
    content:
      authentication_methods:
        api_key_authentication: |
          API key authentication:
          
          **Generation**:
```python
          import secrets
          import hashlib
          
          def generate_api_key() -> tuple[str, str]:
              """
              Generate API key.
              
              Returns:
                  (api_key, api_key_hash)
              """
              # Generate cryptographically secure random key
              api_key = secrets.token_urlsafe(32)  # 256 bits
              
              # Hash for storage (never store plaintext)
              api_key_hash = hashlib.sha256(api_key.encode()).hexdigest()
              
              return api_key, api_key_hash
```
          
          **Storage**:
```python
          # Store hash, not key
          db.execute(
              "INSERT INTO api_keys (user_id, key_hash, created_at) VALUES (?, ?, ?)",
              (user_id, api_key_hash, datetime.now())
          )
          
          # Return key to user ONCE
          return {"api_key": api_key}  # User must save this
```
          
          **Validation**:
```python
          def validate_api_key(api_key: str) -> Optional[dict]:
              """Validate API key and return user info."""
              key_hash = hashlib.sha256(api_key.encode()).hexdigest()
              
              result = db.execute(
                  "SELECT user_id, quota_remaining FROM api_keys WHERE key_hash = ?",
                  (key_hash,)
              ).fetchone()
              
              if not result:
                  return None
              
              return {"user_id": result[0], "quota": result[1]}
```
          
          **Best practices**:
          - Prefix keys: `sk_live_...` (identifies environment)
          - Never log keys: Log hash only
          - Rotation: Force rotation every 90 days
          - Scoping: Limit permissions per key
        
        oauth_jwt_authentication: |
          OAuth 2.0 and JWT authentication:
          
          **OAuth flow** (for third-party apps):
```
          1. User clicks "Login with LLM Service"
          2. Redirected to authorization server
          3. User grants permissions
          4. Redirect back with authorization code
          5. Exchange code for access token
          6. Use access token for API requests
```
          
          **JWT (JSON Web Token)**:
```python
          import jwt
          from datetime import datetime, timedelta
          
          def generate_jwt(user_id: str, secret_key: str) -> str:
              """Generate JWT token."""
              payload = {
                  "user_id": user_id,
                  "exp": datetime.utcnow() + timedelta(hours=1),
                  "iat": datetime.utcnow(),
                  "scope": ["read", "write"]
              }
              
              token = jwt.encode(payload, secret_key, algorithm="HS256")
              return token
          
          def validate_jwt(token: str, secret_key: str) -> Optional[dict]:
              """Validate JWT and return payload."""
              try:
                  payload = jwt.decode(token, secret_key, algorithms=["HS256"])
                  return payload
              except jwt.ExpiredSignatureError:
                  return None  # Token expired
              except jwt.InvalidTokenError:
                  return None  # Invalid token
```
          
          **Benefits**:
          - Stateless (no database lookup)
          - Time-limited (expires automatically)
          - Scope-based permissions
        
        multi_factor_authentication: |
          Multi-factor authentication (MFA):
          
          **TOTP (Time-based One-Time Password)**:
```python
          import pyotp
          
          def setup_mfa(user_id: str) -> str:
              """Setup MFA for user."""
              # Generate secret
              secret = pyotp.random_base32()
              
              # Store secret (encrypted)
              db.execute(
                  "UPDATE users SET mfa_secret = ? WHERE id = ?",
                  (encrypt(secret), user_id)
              )
              
              # Return provisioning URI (for QR code)
              totp = pyotp.TOTP(secret)
              uri = totp.provisioning_uri(
                  name=user_id,
                  issuer_name="LLM Service"
              )
              
              return uri
          
          def verify_mfa(user_id: str, code: str) -> bool:
              """Verify MFA code."""
              # Get secret
              secret = get_user_mfa_secret(user_id)
              if not secret:
                  return False
              
              # Verify code
              totp = pyotp.TOTP(decrypt(secret))
              return totp.verify(code, valid_window=1)
```
          
          **Use case**: Admin accounts, high-value operations
      
      authorization_models:
        rbac_implementation: |
          Role-Based Access Control (RBAC):
          
          **Roles and permissions**:
```python
          roles = {
              "admin": [
                  "users:read", "users:write", "users:delete",
                  "models:read", "models:write",
                  "billing:read", "billing:write"
              ],
              "developer": [
                  "models:read", "models:write",
                  "api_keys:read", "api_keys:write"
              ],
              "viewer": [
                  "models:read"
              ]
          }
```
          
          **Permission checking**:
```python
          class RBACEnforcer:
              """RBAC permission enforcer."""
              
              def __init__(self, roles_config: dict):
                  self.roles_config = roles_config
              
              def has_permission(self, user_role: str, permission: str) -> bool:
                  """Check if role has permission."""
                  if user_role not in self.roles_config:
                      return False
                  
                  return permission in self.roles_config[user_role]
              
              def require_permission(self, permission: str):
                  """Decorator to require permission."""
                  def decorator(func):
                      async def wrapper(request, *args, **kwargs):
                          user = request.user
                          
                          if not self.has_permission(user.role, permission):
                              raise HTTPException(
                                  status_code=403,
                                  detail=f"Missing permission: {permission}"
                              )
                          
                          return await func(request, *args, **kwargs)
                      return wrapper
                  return decorator
```
          
          **Usage**:
```python
          rbac = RBACEnforcer(roles)
          
          @app.post("/api/models")
          @rbac.require_permission("models:write")
          async def create_model(request):
              # Only users with models:write can access
              pass
```
        
        abac_implementation: |
          Attribute-Based Access Control (ABAC):
          
          **Policy definition**:
```python
          policies = [
              {
                  "effect": "allow",
                  "conditions": [
                      {"attribute": "user.role", "operator": "equals", "value": "admin"}
                  ]
              },
              {
                  "effect": "allow",
                  "conditions": [
                      {"attribute": "user.department", "operator": "equals", "value": "engineering"},
                      {"attribute": "resource.sensitivity", "operator": "not_equals", "value": "high"}
                  ]
              }
          ]
```
          
          **Policy evaluation**:
```python
          class ABACEnforcer:
              """ABAC policy enforcer."""
              
              def evaluate_policy(self,
                                user_attrs: dict,
                                resource_attrs: dict,
                                action: str) -> bool:
                  """Evaluate if action is allowed."""
                  for policy in self.policies:
                      if self._matches_conditions(policy, user_attrs, resource_attrs):
                          return policy["effect"] == "allow"
                  
                  return False  # Deny by default
              
              def _matches_conditions(self, policy, user_attrs, resource_attrs):
                  """Check if all conditions match."""
                  for condition in policy["conditions"]:
                      attr_name = condition["attribute"]
                      
                      # Get attribute value
                      if attr_name.startswith("user."):
                          value = user_attrs.get(attr_name[5:])
                      elif attr_name.startswith("resource."):
                          value = resource_attrs.get(attr_name[9:])
                      else:
                          value = None
                      
                      # Check condition
                      if not self._check_condition(value, condition):
                          return False
                  
                  return True
```
        
        resource_based_quotas: |
          Resource-based quotas and limits:
```python
          class QuotaManager:
              """Manage user quotas."""
              
              def __init__(self, redis_client):
                  self.redis = redis_client
              
              def check_quota(self,
                            user_id: str,
                            quota_type: str,
                            amount: int = 1) -> bool:
                  """
                  Check if user has quota.
                  
                  Args:
                      user_id: User identifier
                      quota_type: Type of quota (tokens, requests)
                      amount: Amount to consume
                  
                  Returns:
                      True if quota available
                  """
                  # Get user's quota limit
                  limit = self.get_user_limit(user_id, quota_type)
                  
                  # Get current usage (monthly)
                  key = f"quota:{user_id}:{quota_type}:{month}"
                  current = int(self.redis.get(key) or 0)
                  
                  # Check if within limit
                  if current + amount > limit:
                      return False
                  
                  return True
              
              def consume_quota(self, user_id: str, quota_type: str, amount: int):
                  """Consume quota."""
                  key = f"quota:{user_id}:{quota_type}:{month}"
                  self.redis.incrby(key, amount)
                  self.redis.expire(key, 31 * 86400)  # Month
              
              def get_user_limit(self, user_id: str, quota_type: str) -> int:
                  """Get user's quota limit."""
                  # From database or config
                  limits = {
                      "free": {"tokens": 100000, "requests": 1000},
                      "pro": {"tokens": 10000000, "requests": 100000}
                  }
                  
                  user_tier = get_user_tier(user_id)
                  return limits.get(user_tier, {}).get(quota_type, 0)
```
      
      rate_limiting:
        rate_limiting_algorithms: |
          Rate limiting algorithms:
          
          **1. Token bucket**:
```python
          import time
          
          class TokenBucket:
              """Token bucket rate limiter."""
              
              def __init__(self, capacity: int, refill_rate: float):
                  """
                  Initialize token bucket.
                  
                  Args:
                      capacity: Maximum tokens
                      refill_rate: Tokens per second
                  """
                  self.capacity = capacity
                  self.refill_rate = refill_rate
                  self.tokens = capacity
                  self.last_refill = time.time()
              
              def allow_request(self, tokens: int = 1) -> bool:
                  """Check if request allowed."""
                  # Refill tokens
                  now = time.time()
                  elapsed = now - self.last_refill
                  self.tokens = min(
                      self.capacity,
                      self.tokens + elapsed * self.refill_rate
                  )
                  self.last_refill = now
                  
                  # Check if enough tokens
                  if self.tokens >= tokens:
                      self.tokens -= tokens
                      return True
                  
                  return False
```
          
          **2. Sliding window**:
```python
          class SlidingWindowRateLimiter:
              """Sliding window rate limiter (Redis-based)."""
              
              def __init__(self, redis_client):
                  self.redis = redis_client
              
              def allow_request(self,
                              key: str,
                              limit: int,
                              window_seconds: int) -> bool:
                  """Check if request allowed."""
                  now = time.time()
                  window_start = now - window_seconds
                  
                  # Remove old entries
                  self.redis.zremrangebyscore(key, 0, window_start)
                  
                  # Count requests in window
                  count = self.redis.zcard(key)
                  
                  if count >= limit:
                      return False
                  
                  # Add current request
                  self.redis.zadd(key, {str(now): now})
                  self.redis.expire(key, window_seconds)
                  
                  return True
```
        
        adaptive_rate_limiting: |
          Adaptive rate limiting:
```python
          class AdaptiveRateLimiter:
              """Adaptive rate limiter based on load."""
              
              def __init__(self):
                  self.base_limit = 100  # requests per minute
                  self.current_limit = self.base_limit
                  self.load_threshold = 0.8
              
              def update_limit(self, current_load: float):
                  """Update limit based on system load."""
                  if current_load > self.load_threshold:
                      # Reduce limit under high load
                      self.current_limit = int(self.base_limit * 0.5)
                  else:
                      # Restore normal limit
                      self.current_limit = self.base_limit
              
              def allow_request(self, user_id: str) -> bool:
                  """Check if request allowed with adaptive limit."""
                  # Use current_limit instead of base_limit
                  return self.limiter.allow_request(
                      f"rate:{user_id}",
                      limit=self.current_limit,
                      window_seconds=60
                  )
```
      
      audit_logging:
        comprehensive_audit_trail: |
          Comprehensive audit logging:
```python
          class AuditLogger:
              """Audit logger for compliance."""
              
              def __init__(self, db):
                  self.db = db
              
              def log_event(self,
                          event_type: str,
                          user_id: str,
                          resource_type: str,
                          resource_id: str,
                          action: str,
                          result: str,
                          metadata: dict = None):
                  """
                  Log audit event.
                  
                  Args:
                      event_type: Type of event (auth, access, modify)
                      user_id: Who performed action
                      resource_type: What resource (model, api_key)
                      resource_id: Specific resource ID
                      action: Action performed (read, write, delete)
                      result: Result (success, denied, error)
                      metadata: Additional context
                  """
                  event = {
                      "timestamp": datetime.utcnow().isoformat(),
                      "event_type": event_type,
                      "user_id": user_id,
                      "resource_type": resource_type,
                      "resource_id": resource_id,
                      "action": action,
                      "result": result,
                      "metadata": metadata or {},
                      "ip_address": get_client_ip(),
                      "user_agent": get_user_agent()
                  }
                  
                  # Store in database
                  self.db.execute(
                      """
                      INSERT INTO audit_log 
                      (timestamp, event_type, user_id, resource_type, 
                       resource_id, action, result, metadata, ip_address, user_agent)
                      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                      """,
                      tuple(event.values())
                  )
                  
                  # Also log to stdout (structured)
                  print(json.dumps(event))
```
          
          **Usage**:
```python
          audit = AuditLogger(db)
          
          @app.post("/api/models/{model_id}")
          async def update_model(model_id: str, request: Request):
              user = request.user
              
              # Check permission
              if not has_permission(user, "models:write"):
                  audit.log_event(
                      event_type="access",
                      user_id=user.id,
                      resource_type="model",
                      resource_id=model_id,
                      action="write",
                      result="denied"
                  )
                  raise HTTPException(403)
              
              # Perform action
              update_model_in_db(model_id, request.body)
              
              audit.log_event(
                  event_type="modify",
                  user_id=user.id,
                  resource_type="model",
                  resource_id=model_id,
                  action="write",
                  result="success"
              )
```
    
    implementation:
      authentication_authorization_system:
        language: python
        code: |
          """
          Complete authentication and authorization system.
          Demonstrates API keys, RBAC, rate limiting, and audit logging.
          """
          
          import hashlib
          import secrets
          import time
          from typing import Optional, Dict, List
          from datetime import datetime
          from dataclasses import dataclass
          
          @dataclass
          class User:
              """User model."""
              id: str
              email: str
              role: str
              tier: str
          
          
          class APIKeyManager:
              """
              Manage API keys.
              
              Handles generation, validation, and rotation.
              """
              
              def __init__(self):
                  """Initialize key manager."""
                  # In production: use database
                  self.keys = {}  # key_hash -> user_info
              
              def generate_key(self, user_id: str) -> str:
                  """
                  Generate API key for user.
                  
                  Args:
                      user_id: User identifier
                  
                  Returns:
                      API key (show to user once)
                  """
                  # Generate cryptographically secure key
                  api_key = f"sk_live_{secrets.token_urlsafe(32)}"
                  
                  # Hash for storage
                  key_hash = hashlib.sha256(api_key.encode()).hexdigest()
                  
                  # Store hash
                  self.keys[key_hash] = {
                      "user_id": user_id,
                      "created_at": datetime.utcnow(),
                      "last_used": None
                  }
                  
                  return api_key
              
              def validate_key(self, api_key: str) -> Optional[Dict]:
                  """
                  Validate API key.
                  
                  Args:
                      api_key: API key to validate
                  
                  Returns:
                      User info if valid, None otherwise
                  """
                  key_hash = hashlib.sha256(api_key.encode()).hexdigest()
                  
                  if key_hash not in self.keys:
                      return None
                  
                  # Update last used
                  self.keys[key_hash]["last_used"] = datetime.utcnow()
                  
                  return self.keys[key_hash]
              
              def revoke_key(self, api_key: str):
                  """Revoke API key."""
                  key_hash = hashlib.sha256(api_key.encode()).hexdigest()
                  if key_hash in self.keys:
                      del self.keys[key_hash]
          
          
          class RBACEnforcer:
              """
              Role-Based Access Control enforcer.
              
              Manages roles, permissions, and policy enforcement.
              """
              
              def __init__(self):
                  """Initialize RBAC enforcer."""
                  self.roles = {
                      "admin": [
                          "users:read", "users:write", "users:delete",
                          "models:read", "models:write", "models:delete",
                          "api_keys:read", "api_keys:write", "api_keys:delete"
                      ],
                      "developer": [
                          "models:read", "models:write",
                          "api_keys:read", "api_keys:write"
                      ],
                      "viewer": [
                          "models:read"
                      ]
                  }
              
              def has_permission(self, user: User, permission: str) -> bool:
                  """
                  Check if user has permission.
                  
                  Args:
                      user: User object
                      permission: Required permission
                  
                  Returns:
                      True if user has permission
                  """
                  if user.role not in self.roles:
                      return False
                  
                  return permission in self.roles[user.role]
              
              def require_permission(self, user: User, permission: str):
                  """
                  Require permission (raise if not authorized).
                  
                  Args:
                      user: User object
                      permission: Required permission
                  
                  Raises:
                      PermissionError if not authorized
                  """
                  if not self.has_permission(user, permission):
                      raise PermissionError(
                          f"User {user.id} missing permission: {permission}"
                      )
          
          
          class RateLimiter:
              """
              Rate limiter using sliding window.
              
              Prevents abuse through request rate limiting.
              """
              
              def __init__(self):
                  """Initialize rate limiter."""
                  # In production: use Redis
                  self.windows = {}  # user_id -> [(timestamp, count)]
              
              def allow_request(self,
                              user_id: str,
                              limit: int = 100,
                              window_seconds: int = 60) -> bool:
                  """
                  Check if request allowed.
                  
                  Args:
                      user_id: User identifier
                      limit: Max requests per window
                      window_seconds: Window size in seconds
                  
                  Returns:
                      True if allowed
                  """
                  now = time.time()
                  window_start = now - window_seconds
                  
                  # Initialize window
                  if user_id not in self.windows:
                      self.windows[user_id] = []
                  
                  # Remove old entries
                  self.windows[user_id] = [
                      (ts, count) for ts, count in self.windows[user_id]
                      if ts > window_start
                  ]
                  
                  # Count requests in window
                  count = sum(c for _, c in self.windows[user_id])
                  
                  if count >= limit:
                      return False
                  
                  # Add current request
                  self.windows[user_id].append((now, 1))
                  
                  return True
          
          
          class AuditLogger:
              """
              Audit logger for compliance.
              
              Logs all access and modifications for audit trail.
              """
              
              def __init__(self):
                  """Initialize audit logger."""
                  self.logs = []
              
              def log(self,
                     event_type: str,
                     user_id: str,
                     action: str,
                     resource: str,
                     result: str,
                     metadata: Dict = None):
                  """
                  Log audit event.
                  
                  Args:
                      event_type: Type of event
                      user_id: Who performed action
                      action: Action performed
                      resource: Resource accessed
                      result: Result (success, denied, error)
                      metadata: Additional context
                  """
                  log_entry = {
                      "timestamp": datetime.utcnow().isoformat(),
                      "event_type": event_type,
                      "user_id": user_id,
                      "action": action,
                      "resource": resource,
                      "result": result,
                      "metadata": metadata or {}
                  }
                  
                  self.logs.append(log_entry)
                  print(f"[AUDIT] {log_entry}")
              
              def get_user_activity(self, user_id: str) -> List[Dict]:
                  """Get all activity for user."""
                  return [log for log in self.logs if log["user_id"] == user_id]
          
          
          class SecureAPIService:
              """
              Secure API service with authentication, authorization, and audit.
              
              Complete implementation of API security controls.
              """
              
              def __init__(self):
                  """Initialize secure API service."""
                  self.api_keys = APIKeyManager()
                  self.rbac = RBACEnforcer()
                  self.rate_limiter = RateLimiter()
                  self.audit = AuditLogger()
                  
                  # Mock user database
                  self.users = {}
              
              def register_user(self, user_id: str, email: str, role: str, tier: str) -> User:
                  """Register new user."""
                  user = User(id=user_id, email=email, role=role, tier=tier)
                  self.users[user_id] = user
                  return user
              
              def create_api_key(self, user_id: str) -> str:
                  """Create API key for user."""
                  api_key = self.api_keys.generate_key(user_id)
                  
                  self.audit.log(
                      event_type="api_key",
                      user_id=user_id,
                      action="create",
                      resource="api_key",
                      result="success"
                  )
                  
                  return api_key
              
              def handle_request(self,
                                api_key: str,
                                action: str,
                                resource: str) -> Dict:
                  """
                  Handle API request with full security controls.
                  
                  Args:
                      api_key: API key for authentication
                      action: Action to perform
                      resource: Resource to access
                  
                  Returns:
                      Response dict
                  """
                  # 1. Authenticate
                  key_info = self.api_keys.validate_key(api_key)
                  if not key_info:
                      self.audit.log(
                          event_type="auth",
                          user_id="unknown",
                          action=action,
                          resource=resource,
                          result="invalid_key"
                      )
                      return {"error": "Invalid API key", "status": 401}
                  
                  user_id = key_info["user_id"]
                  user = self.users.get(user_id)
                  
                  # 2. Rate limiting
                  if not self.rate_limiter.allow_request(user_id):
                      self.audit.log(
                          event_type="rate_limit",
                          user_id=user_id,
                          action=action,
                          resource=resource,
                          result="rate_limited"
                      )
                      return {"error": "Rate limit exceeded", "status": 429}
                  
                  # 3. Authorization
                  required_permission = f"{resource}:{action}"
                  if not self.rbac.has_permission(user, required_permission):
                      self.audit.log(
                          event_type="authz",
                          user_id=user_id,
                          action=action,
                          resource=resource,
                          result="denied"
                      )
                      return {"error": "Permission denied", "status": 403}
                  
                  # 4. Process request
                  result = self._process_request(user, action, resource)
                  
                  # 5. Audit log
                  self.audit.log(
                      event_type="access",
                      user_id=user_id,
                      action=action,
                      resource=resource,
                      result="success"
                  )
                  
                  return {"data": result, "status": 200}
              
              def _process_request(self, user: User, action: str, resource: str):
                  """Process the actual request (mock)."""
                  return f"Processed {action} on {resource} for user {user.id}"
          
          
          def demonstrate_api_security():
              """Demonstrate API security system."""
              print("\n" + "="*80)
              print("API SECURITY DEMONSTRATION")
              print("="*80)
              
              service = SecureAPIService()
              
              # Register users
              print("\n" + "-"*80)
              print("Registering users...")
              print("-"*80)
              
              admin = service.register_user("user1", "admin@example.com", "admin", "enterprise")
              dev = service.register_user("user2", "dev@example.com", "developer", "pro")
              viewer = service.register_user("user3", "viewer@example.com", "viewer", "free")
              
              # Create API keys
              admin_key = service.create_api_key(admin.id)
              dev_key = service.create_api_key(dev.id)
              viewer_key = service.create_api_key(viewer.id)
              
              print(f"Admin key: {admin_key[:20]}...")
              print(f"Developer key: {dev_key[:20]}...")
              print(f"Viewer key: {viewer_key[:20]}...")
              
              # Test requests
              print("\n" + "-"*80)
              print("Testing access control...")
              print("-"*80)
              
              # Admin can do everything
              print("\n1. Admin writes model (should succeed):")
              response = service.handle_request(admin_key, "write", "models")
              print(f"   Status: {response['status']}")
              
              # Developer can write models
              print("\n2. Developer writes model (should succeed):")
              response = service.handle_request(dev_key, "write", "models")
              print(f"   Status: {response['status']}")
              
              # Viewer cannot write models
              print("\n3. Viewer writes model (should fail - permission denied):")
              response = service.handle_request(viewer_key, "write", "models")
              print(f"   Status: {response['status']}, Error: {response.get('error')}")
              
              # Invalid key
              print("\n4. Invalid key (should fail - auth error):")
              response = service.handle_request("sk_invalid_key", "read", "models")
              print(f"   Status: {response['status']}, Error: {response.get('error')}")
              
              # Rate limiting
              print("\n5. Rate limiting (100 requests, then block):")
              for i in range(102):
                  response = service.handle_request(viewer_key, "read", "models")
                  if response['status'] == 429:
                      print(f"   Rate limited after {i} requests")
                      break
              
              # Audit trail
              print("\n" + "-"*80)
              print("Audit trail for viewer:")
              print("-"*80)
              viewer_activity = service.audit.get_user_activity(viewer.id)
              for log in viewer_activity[-5:]:  # Last 5 events
                  print(f"  {log['timestamp']}: {log['action']} on {log['resource']} - {log['result']}")
          
          
          if __name__ == "__main__":
              demonstrate_api_security()
    
    security_implications:
      api_key_compromise: |
        **Vulnerability**: API keys are compromised through leakage, theft, or interception,
        enabling attackers to impersonate legitimate users and abuse resources.
        
        **Attack scenario 1**: Key committed to GitHub
        - Developer commits code with hardcoded key
        - Public repository → key exposed
        - Attacker finds key, uses it
        - $10K+ in GPU abuse before detection
        
        **Attack scenario 2**: Man-in-the-middle
        - User sends key over HTTP (not HTTPS)
        - Attacker intercepts key
        - Uses key to access API
        
        **Attack scenario 3**: Log leakage
        - Key logged in plaintext
        - Logs exported for analysis
        - Analyst sees key, shares it
        
        **Defense**:
        1. Never hardcode: Use environment variables
        2. Rotation: Force rotation every 90 days
        3. Scoping: Limit permissions per key
        4. Monitoring: Alert on unusual key usage
        5. Revocation: Instant revocation capability
        6. Hash storage: Store hashes, not keys
        7. GitHub scanning: Automated secret detection
      
      privilege_escalation: |
        **Vulnerability**: Attackers escalate privileges from low-privileged accounts to
        admin accounts, gaining unauthorized access to sensitive operations.
        
        **Attack scenario 1**: Role manipulation
        - Attacker has "viewer" account
        - Exploits API to modify own role
        - Changes role to "admin"
        - Full system access
        
        **Attack scenario 2**: Permission bypass
        - Permission check has logic flaw
        - Attacker crafts request that bypasses check
        - Performs unauthorized action
        
        **Attack scenario 3**: JWT tampering
        - JWT signed with weak secret
        - Attacker modifies payload (role: viewer → admin)
        - Re-signs with cracked secret
        - Elevated privileges
        
        **Defense**:
        1. Immutable roles: Users cannot modify own roles
        2. Separation of duties: Role changes require admin approval
        3. Strong JWT secrets: 256-bit secrets, rotated regularly
        4. Permission validation: Check at every layer (API, service, database)
        5. Audit logging: Log all permission checks and failures
        6. Least privilege: Default to minimal permissions
        7. Regular audits: Review user permissions quarterly
      
      insufficient_rate_limiting: |
        **Vulnerability**: Weak or bypassed rate limiting enables attackers to abuse APIs
        through high-volume requests, causing resource exhaustion or cost spikes.
        
        **Attack scenario 1**: Distributed bypass
        - Rate limit is per-IP
        - Attacker uses botnet (1000 IPs)
        - Each IP under limit
        - Total: 1000x limit
        
        **Attack scenario 2**: Key sharing
        - Rate limit is per-key
        - Attacker creates 100 free accounts
        - 100 keys × limit = 100x abuse
        
        **Attack scenario 3**: Time window exploitation
        - Fixed window rate limit resets at midnight
        - Attacker sends 100 requests at 11:59pm
        - Sends 100 more at 12:01am
        - 200 requests in 2 minutes
        
        **Defense**:
        1. Multi-dimensional limiting: Per-IP AND per-key AND per-user
        2. Sliding window: Use sliding window, not fixed
        3. Cost-based limiting: Expensive operations have lower limits
        4. Adaptive limiting: Reduce limits under high load
        5. Account verification: Require verification for accounts
        6. Anomaly detection: Flag unusual usage patterns
        7. Global limits: Hard caps regardless of user count

  - topic_number: 2
    title: "Secrets Management and Regulatory Compliance"
    
    overview: |
      Secrets (API keys, database passwords, encryption keys) must be protected from exposure.
      Hardcoded secrets, environment variables, and config files are all vulnerable. Production
      systems need centralized secrets management with rotation, encryption, and access control.
      
      Regulatory compliance (GDPR, SOC2, HIPAA, ISO 27001) mandates specific controls: data
      protection, access logging, incident response, security audits. Non-compliance risks
      fines (GDPR: 4% revenue), legal liability, and reputational damage. Compliance automation
      reduces manual burden.
      
      We implement secrets management with HashiCorp Vault, build compliance automation for
      GDPR/SOC2, configure audit logging for compliance, and create incident response procedures.
      Understanding compliance enables building legally compliant production services.
    
    content:
      secrets_management:
        vault_deployment: |
          HashiCorp Vault deployment:
          
          **Architecture**:
```
          Application → Vault Client → Vault Server
                                    → Encrypted Storage
```
          
          **Storing secrets**:
```python
          import hvac
          
          # Initialize Vault client
          client = hvac.Client(url='https://vault.example.com:8200')
          
          # Authenticate (AppRole)
          client.auth.approle.login(
              role_id='app-role-id',
              secret_id='app-secret-id'
          )
          
          # Store secret
          client.secrets.kv.v2.create_or_update_secret(
              path='llm-service/production',
              secret={
                  'database_password': 'super_secret_password',
                  'api_key': 'sk_prod_...',
                  'encryption_key': 'base64_encoded_key'
              }
          )
```
          
          **Retrieving secrets**:
```python
          # Read secret
          secret = client.secrets.kv.v2.read_secret_version(
              path='llm-service/production'
          )
          
          db_password = secret['data']['data']['database_password']
```
          
          **Benefits**:
          - Centralized: All secrets in one place
          - Encrypted: Secrets encrypted at rest
          - Audited: All access logged
          - Rotated: Automatic rotation
        
        secret_rotation: |
          Automatic secret rotation:
```python
          class SecretRotator:
              """Automatic secret rotation."""
              
              def __init__(self, vault_client):
                  self.vault = vault_client
              
              def rotate_database_password(self):
                  """Rotate database password."""
                  # Generate new password
                  new_password = secrets.token_urlsafe(32)
                  
                  # Update in database
                  db.execute("ALTER USER app_user PASSWORD ?", (new_password,))
                  
                  # Store in Vault
                  self.vault.secrets.kv.v2.create_or_update_secret(
                      path='llm-service/production',
                      secret={'database_password': new_password}
                  )
                  
                  # Restart services to pick up new password
                  self.restart_services()
              
              def rotate_api_keys(self):
                  """Rotate API keys."""
                  # Get all active keys
                  keys = db.execute("SELECT id, user_id FROM api_keys").fetchall()
                  
                  for key_id, user_id in keys:
                      # Generate new key
                      new_key = generate_api_key()
                      
                      # Update in database
                      db.execute(
                          "UPDATE api_keys SET key_hash = ?, updated_at = ? WHERE id = ?",
                          (hash_key(new_key), datetime.utcnow(), key_id)
                      )
                      
                      # Notify user
                      send_email(user_id, "API key rotated", new_key)
```
          
          **Rotation schedule**:
          - Database passwords: Every 90 days
          - API keys: Every 90 days (optional, user-initiated)
          - Encryption keys: Annually
        
        cloud_secrets_managers: |
          Cloud provider secrets managers:
          
          **AWS Secrets Manager**:
```python
          import boto3
          
          client = boto3.client('secretsmanager', region_name='us-east-1')
          
          # Store secret
          client.create_secret(
              Name='llm-service/production/db',
              SecretString='{"password":"super_secret"}'
          )
          
          # Retrieve secret
          response = client.get_secret_value(SecretId='llm-service/production/db')
          secret = json.loads(response['SecretString'])
```
          
          **GCP Secret Manager**:
```python
          from google.cloud import secretmanager
          
          client = secretmanager.SecretManagerServiceClient()
          
          # Store secret
          parent = f"projects/{project_id}"
          secret = client.create_secret(
              request={"parent": parent, "secret_id": "db-password"}
          )
          
          # Retrieve secret
          name = f"{parent}/secrets/db-password/versions/latest"
          response = client.access_secret_version(request={"name": name})
          password = response.payload.data.decode('UTF-8')
```
          
          **Azure Key Vault**:
```python
          from azure.keyvault.secrets import SecretClient
          from azure.identity import DefaultAzureCredential
          
          credential = DefaultAzureCredential()
          client = SecretClient(vault_url="https://my-vault.vault.azure.net", credential=credential)
          
          # Store secret
          client.set_secret("db-password", "super_secret")
          
          # Retrieve secret
          secret = client.get_secret("db-password")
          password = secret.value
```
      
      regulatory_compliance:
        gdpr_compliance: |
          GDPR (General Data Protection Regulation) compliance:
          
          **Key requirements**:
          1. **Right to access**: Users can request their data
          2. **Right to erasure**: Users can request deletion
          3. **Data portability**: Export data in machine-readable format
          4. **Consent management**: Track and honor consent
          5. **Breach notification**: Report breaches within 72 hours
          
          **Implementation**:
```python
          class GDPRCompliance:
              """GDPR compliance helper."""
              
              def export_user_data(self, user_id: str) -> dict:
                  """Export all user data (Right to access)."""
                  return {
                      "personal_info": db.get_user_info(user_id),
                      "api_keys": db.get_user_api_keys(user_id),
                      "requests": db.get_user_requests(user_id),
                      "billing": db.get_user_billing(user_id)
                  }
              
              def delete_user_data(self, user_id: str):
                  """Delete all user data (Right to erasure)."""
                  # Delete from all tables
                  db.execute("DELETE FROM users WHERE id = ?", (user_id,))
                  db.execute("DELETE FROM api_keys WHERE user_id = ?", (user_id,))
                  db.execute("DELETE FROM requests WHERE user_id = ?", (user_id,))
                  
                  # Anonymize logs (can't delete for audit)
                  db.execute(
                      "UPDATE audit_log SET user_id = 'DELETED' WHERE user_id = ?",
                      (user_id,)
                  )
              
              def track_consent(self, user_id: str, consent_type: str, granted: bool):
                  """Track user consent."""
                  db.execute(
                      "INSERT INTO consent_log (user_id, consent_type, granted, timestamp) VALUES (?, ?, ?, ?)",
                      (user_id, consent_type, granted, datetime.utcnow())
                  )
```
        
        soc2_compliance: |
          SOC 2 (Service Organization Control 2) compliance:
          
          **Trust Services Criteria**:
          1. **Security**: Protection against unauthorized access
          2. **Availability**: System is available as agreed
          3. **Processing Integrity**: Processing is complete and accurate
          4. **Confidentiality**: Confidential information is protected
          5. **Privacy**: Personal information is handled appropriately
          
          **Control implementation**:
```python
          class SOC2Controls:
              """SOC 2 compliance controls."""
              
              def enforce_access_control(self):
                  """CC6.1: Logical access controls."""
                  # Implement RBAC (covered above)
                  # MFA for privileged accounts
                  # Regular access reviews
                  pass
              
              def monitor_system_availability(self):
                  """CC7.1: System availability monitoring."""
                  # Uptime monitoring
                  # Incident response
                  # Capacity planning
                  pass
              
              def encrypt_sensitive_data(self):
                  """CC6.7: Data encryption."""
                  # Encrypt data at rest
                  # Encrypt data in transit (TLS)
                  # Key management
                  pass
              
              def maintain_audit_logs(self):
                  """CC7.3: Audit logging."""
                  # Comprehensive audit trail
                  # Log retention (1 year minimum)
                  # Log protection (immutability)
                  pass
```
        
        hipaa_compliance: |
          HIPAA compliance (if handling health data):
          
          **Key requirements**:
          1. **Encryption**: PHI encrypted at rest and in transit
          2. **Access controls**: Role-based access to PHI
          3. **Audit trails**: Log all PHI access
          4. **Breach notification**: Report breaches to HHS
          5. **Business associate agreements**: Contracts with vendors
          
          **Implementation**:
```python
          class HIPAACompliance:
              """HIPAA compliance for health data."""
              
              def encrypt_phi(self, data: str) -> bytes:
                  """Encrypt protected health information."""
                  from cryptography.fernet import Fernet
                  
                  # Get encryption key from Vault
                  key = vault.get_secret("phi-encryption-key")
                  cipher = Fernet(key)
                  
                  return cipher.encrypt(data.encode())
              
              def log_phi_access(self, user_id: str, patient_id: str, action: str):
                  """Log PHI access for audit."""
                  db.execute(
                      "INSERT INTO phi_access_log (user_id, patient_id, action, timestamp) VALUES (?, ?, ?, ?)",
                      (user_id, patient_id, action, datetime.utcnow())
                  )
              
              def generate_breach_report(self, incident: dict):
                  """Generate breach notification report."""
                  report = {
                      "incident_date": incident["date"],
                      "discovery_date": datetime.utcnow(),
                      "individuals_affected": incident["affected_count"],
                      "phi_types": incident["phi_types"],
                      "mitigation_steps": incident["mitigation"]
                  }
                  
                  # Must notify HHS within 60 days
                  return report
```
        
        compliance_automation: |
          Compliance automation:
```python
          class ComplianceAutomation:
              """Automate compliance checks."""
              
              def run_daily_checks(self):
                  """Daily compliance checks."""
                  checks = [
                      self.check_encryption(),
                      self.check_access_controls(),
                      self.check_audit_logs(),
                      self.check_backup_status()
                  ]
                  
                  failures = [c for c in checks if not c["passed"]]
                  
                  if failures:
                      self.alert_compliance_team(failures)
              
              def check_encryption(self) -> dict:
                  """Verify encryption is enabled."""
                  # Check database encryption
                  db_encrypted = check_db_encryption()
                  
                  # Check S3 encryption
                  s3_encrypted = check_s3_encryption()
                  
                  passed = db_encrypted and s3_encrypted
                  
                  return {
                      "check": "encryption",
                      "passed": passed,
                      "details": f"DB: {db_encrypted}, S3: {s3_encrypted}"
                  }
              
              def check_access_controls(self) -> dict:
                  """Verify access controls are enforced."""
                  # Check for accounts without MFA
                  accounts_without_mfa = db.execute(
                      "SELECT COUNT(*) FROM users WHERE role = 'admin' AND mfa_enabled = FALSE"
                  ).fetchone()[0]
                  
                  passed = accounts_without_mfa == 0
                  
                  return {
                      "check": "access_controls",
                      "passed": passed,
                      "details": f"{accounts_without_mfa} admin accounts without MFA"
                  }
              
              def generate_compliance_report(self, period: str) -> dict:
                  """Generate compliance report for audit."""
                  return {
                      "period": period,
                      "access_reviews_completed": self.count_access_reviews(period),
                      "incidents": self.list_incidents(period),
                      "policy_updates": self.list_policy_updates(period),
                      "training_completed": self.check_training_completion(period),
                      "controls_tested": self.list_control_tests(period)
                  }
```
    
    implementation:
      compliance_system:
        language: python
        code: |
          """
          Compliance and secrets management system.
          Demonstrates GDPR compliance and secrets rotation.
          """
          
          import json
          from typing import Dict, List
          from datetime import datetime, timedelta
          
          class SecretsManager:
              """
              Simple secrets manager (production: use Vault).
              
              Handles secret storage, retrieval, and rotation.
              """
              
              def __init__(self):
                  """Initialize secrets manager."""
                  # In production: encrypted storage
                  self.secrets = {}
                  self.rotation_schedule = {}
              
              def store_secret(self, path: str, secret: Dict):
                  """Store secret."""
                  self.secrets[path] = {
                      "value": secret,
                      "created_at": datetime.utcnow(),
                      "version": 1
                  }
              
              def get_secret(self, path: str) -> Dict:
                  """Retrieve secret."""
                  if path not in self.secrets:
                      raise KeyError(f"Secret not found: {path}")
                  
                  return self.secrets[path]["value"]
              
              def rotate_secret(self, path: str, new_secret: Dict):
                  """Rotate secret to new version."""
                  if path in self.secrets:
                      self.secrets[path]["version"] += 1
                  
                  self.secrets[path] = {
                      "value": new_secret,
                      "created_at": datetime.utcnow(),
                      "version": self.secrets.get(path, {}).get("version", 0) + 1
                  }
              
              def check_rotation_needed(self, path: str, max_age_days: int = 90) -> bool:
                  """Check if secret needs rotation."""
                  if path not in self.secrets:
                      return False
                  
                  age = datetime.utcnow() - self.secrets[path]["created_at"]
                  return age.days > max_age_days
          
          
          class GDPRComplianceManager:
              """
              GDPR compliance manager.
              
              Implements data subject rights and compliance automation.
              """
              
              def __init__(self):
                  """Initialize compliance manager."""
                  # Mock database
                  self.users = {}
                  self.requests = {}
                  self.consent = {}
                  self.audit_log = []
              
              def register_user(self, user_id: str, email: str, data: Dict):
                  """Register user (with consent)."""
                  self.users[user_id] = {
                      "email": email,
                      "data": data,
                      "created_at": datetime.utcnow()
                  }
                  
                  # Record consent
                  self.record_consent(user_id, "data_processing", True)
              
              def record_consent(self, user_id: str, consent_type: str, granted: bool):
                  """Record user consent (GDPR requirement)."""
                  if user_id not in self.consent:
                      self.consent[user_id] = []
                  
                  self.consent[user_id].append({
                      "type": consent_type,
                      "granted": granted,
                      "timestamp": datetime.utcnow()
                  })
                  
                  self._audit_log("consent", user_id, f"{consent_type}: {granted}")
              
              def export_user_data(self, user_id: str) -> Dict:
                  """
                  Export user data (Right to Access - GDPR Article 15).
                  
                  Args:
                      user_id: User identifier
                  
                  Returns:
                      All user data in portable format
                  """
                  if user_id not in self.users:
                      return {}
                  
                  self._audit_log("data_export", user_id, "User data exported")
                  
                  return {
                      "user_info": self.users[user_id],
                      "requests": self.requests.get(user_id, []),
                      "consent_history": self.consent.get(user_id, []),
                      "export_date": datetime.utcnow().isoformat()
                  }
              
              def delete_user_data(self, user_id: str):
                  """
                  Delete user data (Right to Erasure - GDPR Article 17).
                  
                  Args:
                      user_id: User identifier
                  """
                  if user_id not in self.users:
                      return
                  
                  # Delete personal data
                  del self.users[user_id]
                  
                  if user_id in self.requests:
                      del self.requests[user_id]
                  
                  if user_id in self.consent:
                      del self.consent[user_id]
                  
                  # Anonymize audit logs (can't delete for compliance)
                  for log in self.audit_log:
                      if log["user_id"] == user_id:
                          log["user_id"] = "DELETED_USER"
                  
                  self._audit_log("data_deletion", "DELETED_USER", f"User {user_id} data deleted")
              
              def rectify_user_data(self, user_id: str, corrections: Dict):
                  """
                  Rectify user data (Right to Rectification - GDPR Article 16).
                  
                  Args:
                      user_id: User identifier
                      corrections: Data corrections
                  """
                  if user_id in self.users:
                      self.users[user_id]["data"].update(corrections)
                      self._audit_log("data_rectification", user_id, f"Data updated: {list(corrections.keys())}")
              
              def restrict_processing(self, user_id: str, restricted: bool):
                  """
                  Restrict processing (GDPR Article 18).
                  
                  Args:
                      user_id: User identifier
                      restricted: Whether to restrict processing
                  """
                  if user_id in self.users:
                      self.users[user_id]["processing_restricted"] = restricted
                      self._audit_log("processing_restriction", user_id, f"Restricted: {restricted}")
              
              def generate_compliance_report(self) -> Dict:
                  """Generate compliance report."""
                  total_users = len(self.users)
                  consented_users = sum(
                      1 for user_id, consents in self.consent.items()
                      if any(c["granted"] for c in consents)
                  )
                  
                  recent_requests = [
                      log for log in self.audit_log
                      if log["timestamp"] > datetime.utcnow() - timedelta(days=30)
                  ]
                  
                  return {
                      "report_date": datetime.utcnow().isoformat(),
                      "total_users": total_users,
                      "consented_users": consented_users,
                      "data_exports_30d": len([r for r in recent_requests if r["action"] == "data_export"]),
                      "data_deletions_30d": len([r for r in recent_requests if r["action"] == "data_deletion"]),
                      "audit_events": len(self.audit_log)
                  }
              
              def _audit_log(self, action: str, user_id: str, details: str):
                  """Internal audit logging."""
                  self.audit_log.append({
                      "timestamp": datetime.utcnow(),
                      "action": action,
                      "user_id": user_id,
                      "details": details
                  })
          
          
          def demonstrate_compliance():
              """Demonstrate compliance and secrets management."""
              print("\n" + "="*80)
              print("COMPLIANCE AND SECRETS MANAGEMENT DEMONSTRATION")
              print("="*80)
              
              # Secrets management
              print("\n" + "-"*80)
              print("Secrets Management")
              print("-"*80)
              
              secrets = SecretsManager()
              
              # Store secrets
              secrets.store_secret("db/password", {"password": "super_secret_123"})
              secrets.store_secret("api/key", {"key": "sk_prod_abc123"})
              
              print("Stored secrets: db/password, api/key")
              
              # Check rotation
              print(f"DB password needs rotation: {secrets.check_rotation_needed('db/password', max_age_days=90)}")
              
              # Rotate secret
              secrets.rotate_secret("db/password", {"password": "new_secret_456"})
              print("Rotated db/password to version 2")
              
              # GDPR compliance
              print("\n" + "-"*80)
              print("GDPR Compliance")
              print("-"*80)
              
              gdpr = GDPRComplianceManager()
              
              # Register users
              gdpr.register_user("user1", "alice@example.com", {"name": "Alice", "age": 30})
              gdpr.register_user("user2", "bob@example.com", {"name": "Bob", "age": 25})
              print("Registered 2 users with consent")
              
              # Right to Access
              print("\n1. Right to Access (GDPR Article 15):")
              user_data = gdpr.export_user_data("user1")
              print(f"   Exported data for user1: {len(json.dumps(user_data))} bytes")
              
              # Right to Rectification
              print("\n2. Right to Rectification (GDPR Article 16):")
              gdpr.rectify_user_data("user1", {"age": 31})
              print("   Updated age for user1")
              
              # Right to Erasure
              print("\n3. Right to Erasure (GDPR Article 17):")
              gdpr.delete_user_data("user2")
              print("   Deleted all data for user2")
              
              # Compliance report
              print("\n" + "-"*80)
              print("Compliance Report")
              print("-"*80)
              
              report = gdpr.generate_compliance_report()
              print(f"Total users: {report['total_users']}")
              print(f"Consented users: {report['consented_users']}")
              print(f"Data exports (30d): {report['data_exports_30d']}")
              print(f"Data deletions (30d): {report['data_deletions_30d']}")
              print(f"Total audit events: {report['audit_events']}")
          
          
          if __name__ == "__main__":
              demonstrate_compliance()
    
    security_implications:
      secrets_in_code: |
        **Vulnerability**: Secrets hardcoded in source code are exposed through repository
        access, code review, or accidental commits to public repositories.
        
        **Attack scenario**: Developer commits code with hardcoded API key
        - Code pushed to GitHub (even private repo)
        - Repository made public accidentally
        - GitHub scans commits, finds key
        - Attacker uses key for unauthorized access
        - $10K+ in GPU abuse before detection
        
        **Defense**:
        1. Never hardcode: Use environment variables or secrets manager
        2. GitHub scanning: Automated secret detection (GitHub Advanced Security)
        3. Pre-commit hooks: Block commits with secrets
        4. Code review: Manual review for secrets
        5. Rotation: Assume compromise, rotate regularly
        6. Education: Train developers on secure practices
        7. .gitignore: Exclude config files with secrets
      
      compliance_violations: |
        **Vulnerability**: Non-compliance with regulations (GDPR, HIPAA) results in fines,
        legal liability, and reputational damage.
        
        **Attack scenario 1**: GDPR violation
        - User requests data deletion (Right to Erasure)
        - Company fails to delete within 30 days
        - User files complaint with DPA
        - Fine: Up to 4% of annual revenue
        
        **Attack scenario 2**: Data breach without notification
        - Breach occurs, exposing user data
        - Company delays notification beyond 72 hours
        - GDPR Article 33 violation
        - Fine + legal liability
        
        **Attack scenario 3**: No consent tracking
        - Process user data without documented consent
        - GDPR Article 6 violation
        - Fine + forced data deletion
        
        **Defense**:
        1. Compliance automation: Automated checks and reports
        2. Data mapping: Know what data you have and where
        3. Consent management: Track all consent granularly
        4. Incident response: Documented breach notification process
        5. Regular audits: Quarterly compliance reviews
        6. Legal counsel: Consult privacy lawyers
        7. Staff training: GDPR/compliance training for all staff
      
      insufficient_audit_trail: |
        **Vulnerability**: Incomplete or missing audit logs prevent forensic investigation,
        compliance verification, and incident response.
        
        **Attack scenario**: Insider threat
        - Malicious employee accesses sensitive data
        - No audit logging of access
        - Data exfiltrated
        - Forensic investigation finds no evidence
        - Cannot determine what was accessed
        
        **Defense**:
        1. Comprehensive logging: Log all access and modifications
        2. Immutable logs: Write-once storage
        3. Log forwarding: Send to separate system immediately
        4. Retention: Keep logs 1-7 years depending on regulation
        5. Monitoring: Alert on unusual access patterns
        6. Regular reviews: Periodic log audits
        7. Encryption: Encrypt logs to prevent tampering

key_takeaways:
  critical_concepts:
    - concept: "Authentication verifies identity (who), authorization determines permissions (what), both essential for API security"
      why_it_matters: "Without authentication, anyone can access. Without authorization, authenticated users do anything. Need both for proper access control."
    
    - concept: "API keys must be hashed for storage, rotated regularly, and scoped to minimum necessary permissions"
      why_it_matters: "Plaintext keys are stolen easily. Unrotated keys stay compromised forever. Overprivileged keys enable excessive damage. Proper key management limits blast radius."
    
    - concept: "Secrets management (Vault, cloud providers) provides centralized storage, encryption, rotation, and audit logging"
      why_it_matters: "Hardcoded secrets are exposed. Environment variables are leaked. Centralized secrets management provides security, rotation, and compliance."
    
    - concept: "Compliance (GDPR, SOC2, HIPAA) mandates specific controls: data protection, audit logging, breach notification, access controls"
      why_it_matters: "Non-compliance risks fines (GDPR: 4% revenue), legal liability, and reputation damage. Compliance is not optional for production systems."
  
  actionable_steps:
    - step: "Implement API key authentication with SHA-256 hashing for storage and never store plaintext keys"
      verification: "Verify keys are hashed in database. Attempt to retrieve plaintext key—should be impossible. Only hash stored."
    
    - step: "Build RBAC system with roles (admin, developer, viewer) and enforce permissions at every API endpoint"
      verification: "Test permission enforcement: viewer should fail to write, developer should succeed. Verify all endpoints check permissions."
    
    - step: "Deploy secrets management with HashiCorp Vault or cloud provider and migrate all secrets from environment variables"
      verification: "All secrets should be in Vault. No secrets in code, env files, or configs. Application retrieves from Vault only."
    
    - step: "Implement GDPR data subject rights: data export, deletion, rectification with comprehensive audit logging"
      verification: "Test each right: export should return all data, deletion should remove all PII, rectification should update. Verify audit logs."
  
  security_principles:
    - principle: "Defense-in-depth for authentication: API keys + rate limiting + IP allowlisting + MFA for admins"
      application: "Multiple layers prevent single point of failure. Key compromise doesn't grant unlimited access if rate limiting catches abuse."
    
    - principle: "Least privilege for authorization: users get minimum permissions needed, no more"
      application: "Default deny. Grant specific permissions. Regular access reviews. Revoke unused permissions. Limits damage from compromise."
    
    - principle: "Secrets rotation as default: assume compromise, rotate regularly (90 days max)"
      application: "Automated rotation for database passwords, API keys. Limits exposure window. Old keys expire automatically."
    
    - principle: "Comprehensive audit logging: log everything for compliance, forensics, and incident response"
      application: "Log all access, modifications, deletions. Immutable storage. Forward immediately. Retain per regulation (1-7 years)."
  
  common_mistakes:
    - mistake: "Storing API keys in plaintext in database, enabling theft through database compromise"
      fix: "Hash keys with SHA-256. Store hash only. Compare hashes for validation. Never store plaintext."
    
    - mistake: "No API key rotation policy, leaving compromised keys valid indefinitely"
      fix: "Force rotation every 90 days. Automated rotation for internal keys. Notify users for external keys."
    
    - mistake: "Hardcoding secrets in code or committing to version control"
      fix: "Use environment variables or secrets manager. Never hardcode. Pre-commit hooks block secrets. GitHub scanning."
    
    - mistake: "No audit logging of data access, preventing compliance verification and forensics"
      fix: "Log all access to sensitive data. Include who, what, when, result. Immutable storage. Retain per regulation."
    
    - mistake: "Ignoring GDPR/compliance requirements, risking fines and legal liability"
      fix: "Implement data subject rights. Consent tracking. Breach notification. Regular audits. Legal counsel."
  
  integration_with_book:
    from_section_4_16:
      - "Audit logging (4.17) builds on monitoring infrastructure (4.16)"
      - "Structured logs from 4.16 provide audit trail for compliance"
      - "Metrics from 4.16 track authentication/authorization events"
    
    to_next_section:
      - "Section 4.18: Advanced attacks and red team testing"
      - "Offensive security perspective: testing defenses from 4.17"
      - "Adversarial techniques against authentication, authorization, compliance"
  
  looking_ahead:
    next_concepts:
      - "Advanced attacks on production systems (4.18)"
      - "Red team testing and adversarial techniques (4.18)"
      - "Defense-in-depth and comprehensive security (4.19)"
      - "Incident response and disaster recovery (4.20)"
    
    skills_to_build:
      - "Implementing robust authentication systems"
      - "Building comprehensive authorization with RBAC/ABAC"
      - "Operating secrets management systems"
      - "Managing compliance and regulatory requirements"
  
  final_thoughts: |
    API security and compliance are foundations of production systems. Section 4.17 provides
    the controls needed to protect sensitive data, prevent unauthorized access, and meet
    regulatory requirements.
    
    Key insights:
    
    1. **Authentication and authorization are not optional**: Without them, anyone accesses
       anything. API key compromise costs $10K+ in GPU abuse. Privilege escalation grants
       admin access. Robust authentication (hashed keys, rotation, MFA) and authorization
       (RBAC, least privilege) are essential.
    
    2. **Secrets management prevents catastrophic leaks**: Hardcoded secrets are exposed
       through GitHub, logs, code review. Environment variables are leaked. Centralized
       secrets management (Vault, cloud providers) provides encryption, rotation, audit
       logging, and compliance.
    
    3. **Compliance is business requirement, not technical**: GDPR fines reach 4% of revenue.
       HIPAA violations cause legal liability. SOC2 is required for enterprise sales.
       Compliance automation reduces burden, but legal counsel essential. Non-compliance
       is existential risk.
    
    4. **Audit logging enables compliance and forensics**: Without comprehensive logs,
       can't prove compliance, investigate incidents, or prosecute attackers. Immutable
       logs with retention (1-7 years) are mandatory for most regulations.
    
    5. **Defense-in-depth for production**: No single control is perfect. API keys +
       rate limiting + IP allowlisting + MFA creates layers. Key compromise doesn't grant
       unlimited access if rate limiting catches abuse. Multiple layers essential.
    
    Moving forward, Section 4.18 advances to offensive security: advanced attacks on
    production systems, red team testing, and adversarial techniques. Understanding
    attacks enables building better defenses.
    
    Remember: Security and compliance are not features—they're requirements. Build them
    in from day one. Retrofit is expensive and risky. Invest in proper authentication,
    authorization, secrets management, and compliance automation. Production systems
    demand production security.

---
